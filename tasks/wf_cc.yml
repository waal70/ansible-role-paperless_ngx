---
    # wf_name: "{{ item[0] }}"
    # wf_filter: "{{ item[1] }}"
    # wf_correspondent: "{{ item[2] }}"
    # wf_triggertype
    # wf_filter could be a list, in which case the triggers part should be handled differently...

- name: Initialize looper and triggersection variable
  ansible.builtin.set_fact:
    looper: []
    triggersection: []

- name: Convert wf_filter into a list if it is just a single string
  ansible.builtin.set_fact:
    looper: "{{ looper + [wf_filter] }}"
  when: wf_filter is string

- name: Add wf_filter to the looper variable if it was already a list
  ansible.builtin.set_fact:
    looper: "{{ wf_filter }}"
  when: wf_filter is not string and wf_filter is not mapping and wf_filter is iterable

- name: Prepare the JSON for the triggersection of the API-call
  ansible.builtin.set_fact:
    triggersection: "{{ triggersection +
                      [{'type': wf_triggertype,
                        'filter_filename': item}] }}"
  loop: "{{ looper }}"

- name: "Populate the JMESPath query strings"
  block:
    - name: "Populate correspondent for {{ wf_correspondent }}"
      ansible.builtin.set_fact:
        q_correspondent_id: "results[?name==`{{ wf_correspondent }}`].id"
      when: wf_correspondent != ''
### END BLOCK

- name: "Creating workflow {{ wf_name }}"
  ansible.builtin.uri:
    url: "{{ ppl_endpoint }}workflows/"
    method: POST
    headers:
      Authorization: "Token {{ auth_token }}"
    validate_certs: false
    body_format: json
    body: {
      "name": "{{ wf_name }}",
      "enabled": true,
      "triggers": "{{ triggersection }}",
      "actions": [
        {
          "type": 1,
          "assign_correspondent": "{{ correspondents_response.json | community.general.json_query(q_correspondent_id) | first | default('') }}"
        }
      ]
    }
    status_code:
      - 201
  when: "(wf_name not in wf_response.json.results | map(attribute='name') | list)"
  register: _result
  until: _result.status == 201
  retries: 3
  delay: 5
