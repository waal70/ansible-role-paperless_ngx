---
# This include_vars allows you to keep your vaulted variables outside of your main repo
# It assumes the PRIVATE_REPO environment variable is set to the path of your private repo
# On home-infra, this is done by firstrun.sh.
# However, this role will not break if you do not have these
- name: Include vaulted password file
  ansible.builtin.include_vars:
    file: "{{ item }}"
  with_first_found:
    - files:
        - "{{ lookup('env', 'PRIVATE_REPO') | default('~') }}/ansible-vault/{{ ansible_role_name }}-vars.yml"
      skip: true

- name: "Block for consumption mapping"
  when: cifs_consume_path is defined and cifs_consume_src is defined
  block:
    - name: "Ensure credentials files exist"
      ansible.builtin.copy:
        src: "{{ lookup('ansible.builtin.env', 'PRIVATE_REPO', default='~') }}/ansible-vault/.consumecreds"
        dest: /media/.consumecreds
        owner: root
        group: root
        mode: '0600'
        remote_src: false
        force: true
    - name: "Ensure consume path exists"
      ansible.builtin.file:
        path: "{{ cifs_consume_path }}"
        state: directory
        owner: "{{ interactive_user }}"
        group: "{{ interactive_user }}"
        mode: '0755'
    - name: "Ensure fstab contains CIFS for consume folder"
      ansible.posix.mount:
        path: "{{ cifs_consume_path }}"
        src: "{{ cifs_consume_src }}"
        fstype: cifs
        opts: "uid=0,credentials=/media/.consumecreds,iocharset=utf8,vers=3.0,noperm,x-systemd.automount,x-systemd.idle-timeout=30,x-systemd.mount-timeout=10"
        state: mounted
# END Block for consumption mapping

- name: "Block for export mapping"
  when: cifs_export_path is defined and cifs_export_src is defined
  block:
    - name: "Ensure credentials files exist"
      ansible.builtin.copy:
        src: "{{ lookup('ansible.builtin.env', 'PRIVATE_REPO', default='~') }}/ansible-vault/.exportcreds"
        dest: /media/.exportcreds
        owner: root
        group: root
        mode: '0600'
        remote_src: false
        force: true
    - name: "Ensure export path exists"
      ansible.builtin.file:
        path: "{{ cifs_export_path }}"
        state: directory
        owner: "{{ interactive_user }}"
        group: "{{ interactive_user }}"
        mode: '0755'
    - name: "Ensure fstab contains CIFS for export folder"
      ansible.posix.mount:
        path: "{{ cifs_export_path }}"
        src: "{{ cifs_export_src }}"
        fstype: cifs
        opts: "uid=0,credentials=/media/.consumecreds,iocharset=utf8,vers=3.0,noperm,x-systemd.automount,x-systemd.idle-timeout=30,x-systemd.mount-timeout=10"
        state: mounted
# END Block for export mapping

- name: "Template the paperless.yml file to the role's files/ directory"
  ansible.builtin.template:
    src: paperless.yml.j2
    dest: "{{ role_path }}/files/paperless.yml"
    owner: "{{ interactive_user }}"
    group: "{{ interactive_user }}"
    mode: '0644'
    force: true
  delegate_to: localhost

- name: "Include role to deploy paperless-ngx-stack to Portainer"
  ansible.builtin.include_role:
    name: waal70.portainer
  vars:
    stack_list:
      - name: paperless
        file: paperless.yml # file is in files/ of this role

- name: "Wait for stack to be fully started by querying the /schema/view/ endpoint"
  ansible.builtin.uri:
    url: "{{ ppl_endpoint }}/schema/view/"
    method: GET
    validate_certs: false
  register: wait_ppl_result
  until: wait_ppl_result is succeeded
  retries: 15
  delay: 10
  changed_when: false

- name: "Return the paperless yaml back to its placeholder version"
  ansible.builtin.copy:
    src: paperless.yml.placeholder
    dest: "{{ role_path }}/files/paperless.yml"
    owner: "{{ interactive_user }}"
    group: "{{ interactive_user }}"
    mode: '0644'
    remote_src: false
    force: true
  delegate_to: localhost

- name: "Generate authentication token for user ID {{ ppl_user }} on {{ ppl_endpoint }}" # noqa: name[template]
  ansible.builtin.uri:
    url: "{{ ppl_endpoint }}token/"
    method: POST
    return_content: true
    body_format: json
    body:
      "username": "{{ ppl_user }}"
      "password": "{{ ppl_password }}"
    validate_certs: false
  register: auth_response
  until: auth_response.status == 200
  retries: 5
  delay: 3
  changed_when: false # prevent Ansible from thinking this task changed something

- name: "Set auth_token fact"
  ansible.builtin.set_fact:
    auth_token: "{{ auth_response.json.token }}"
  changed_when: false # prevent Ansible from thinking this task changed something

# This is the user that will own all the config, so it should be properly authorized!
# You can find the ID by GET'ing the /api/users, which can be easily done through:
# http://<address-of-paperless>:8010/api/schema/view/
# ppl_owner: 3
# users/?username__iexact=ppl'

- name: "Setting ppl_owner - query the user ID for user {{ ppl_user }}" # noqa: name[template]
  ansible.builtin.uri:
    url: "{{ ppl_endpoint }}users/?username={{ ppl_user }}"
    method: GET
    validate_certs: false
    headers:
      Authorization: "Token {{ auth_token }}"
  register: ppl_user_response
  until: ppl_user_response.status == 200
  retries: 5
  delay: 3
  changed_when: false # prevent Ansible from thinking this task changed something

- name: "Set ppl_owner fact"
  ansible.builtin.set_fact:
    ppl_owner: "{{ ppl_user_response.json.results[0].id }}"

- name: "Set some config on {{ ppl_endpoint }}"
  ansible.builtin.uri:
    url: "{{ ppl_endpoint }}config/1/"
    method: PATCH
    headers:
      Authorization: "Token {{ auth_token }}"
    validate_certs: false
    body_format: json
    body:
      "rotate_pages": true
      "deskew": true
      "rotate_pages_threshold": 10
      "language": "nld"
      "output_type": "pdfa"
      "mode": "skip"
      "skip_archive_file": "never"
      "unpaper_clean": "clean"
      "color_conversion_strategy": "LeaveColorUnchanged"

- name: "Block to do configuration. Do not perform this when restoring from export."
  when: ppl_do_config
  block:
    - name: "Include tasks to create custom fields"
      ansible.builtin.include_tasks: cf_main.yml

    - name: "Include tasks to handle document types"
      ansible.builtin.include_tasks: doc_type_main.yml

    - name: "Include tasks to handle correspondents"
      ansible.builtin.include_tasks: correspondent_main.yml

    - name: "Include tasks to handle tags"
      ansible.builtin.include_tasks: tags_main.yml

    - name: "Include tasks to handle e-mail settings"
      ansible.builtin.include_tasks: mail.yml
      when: "'@' in mail_username"

    - name: "Include tasks to create Storage Paths"
      ansible.builtin.include_tasks: sp_main.yml

    - name: "Include tasks to create workflows"
      ansible.builtin.include_tasks: wf_main.yml

    - name: "Include task to cleanse document titles"
      ansible.builtin.include_tasks: cleanse_doc_titles.yml
      when: cleanse_titles | bool
# END Block to do configuration

- name: "Include tasks to EXPORT and/or CRON schedule the export of database"
  ansible.builtin.include_tasks: ppl_export.yml
  when:
    - (ppl_export | bool) or (ppl_export_schedule | bool)
    - "'test' not in group_names"
